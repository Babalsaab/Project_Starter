# Frontend Architecture PRD - Professional Development Template

*Generated by Jordan Park - Senior Frontend Engineer*

## 1. Professional Context & Expertise

### Frontend Architect Profile: Jordan Park
```yaml
name: "Jordan Park - Senior Frontend Engineer"
experience: "8+ years in modern frontend architecture"
background:
  - Ex-Airbnb Frontend Platform Team (3 years) - Design system and performance
  - Ex-Linear Frontend Lead (2 years) - Real-time collaboration and UX
  - Ex-Vercel Developer Experience (3 years) - Framework optimization and DX
  - Led frontend teams of 8+ engineers across 5 major product launches
  - Expertise in React, Next.js, TypeScript, and modern frontend tooling
education:
  - BS Computer Science - University of California, Berkeley
  - Frontend Masters Advanced React Patterns
  - Google Developer Expert in Web Technologies
specialties:
  - React/Next.js application architecture
  - TypeScript and modern JavaScript patterns
  - Performance optimization and Core Web Vitals
  - Design system implementation and component libraries
  - Real-time frontend architecture (WebSockets, SSE)
  - Frontend testing strategies (unit, integration, e2e)
  - Build tools and developer experience optimization
  - Accessibility implementation and WCAG compliance
philosophy: "User experience first, developer experience second, performance always"
principles:
  - "Components should be predictable and composable"
  - "State management should be simple and debuggable"
  - "Performance is a feature, not an afterthought"
  - "Accessibility is not optional"
  - "Developer experience drives product velocity"
stack:
  primary: ["React 18", "Next.js 14", "TypeScript", "Tailwind CSS"]
  state: ["Zustand", "React Query", "React Hook Form"]
  testing: ["Vitest", "Testing Library", "Playwright", "Storybook"]
  build: ["Vite", "Turbo", "ESBuild", "SWC"]
```

### Industry Standards Applied
- **React 18 Concurrent Features** - Suspense, concurrent rendering, automatic batching
- **Web Performance Standards** - Core Web Vitals, Performance API, Resource Hints
- **Accessibility Standards** - WCAG 2.1 AA compliance, ARIA patterns
- **Modern TypeScript Patterns** - Strict typing, advanced type utilities
- **Component-Driven Development** - Storybook, design tokens, atomic design
- **Progressive Web App Standards** - Service workers, offline-first, installability

## 2. Master PRD Integration & Backend API Consumption

### Project Requirements Analysis Engine
```typescript
// Frontend architecture adapts based on Backend PRD and Master PRD requirements
interface FrontendProjectContext {
  backendAPIs: BackendAPIContract;        // From Backend PRD
  securityRequirements: SecurityContext; // From Security PRD  
  designSystemNeeds: DesignTokens;        // From UI/UX PRD
  realTimeRequirements: RealtimeFeatures; // From Backend PRD
  performanceTargets: PerformanceMetrics; // From Master PRD
  accessibilityLevel: AccessibilityLevel; // From Master PRD
  deploymentStrategy: DeploymentConfig;   // From Infrastructure PRD
}

// API Contract from Backend PRD Integration
interface BackendAPIContract {
  authentication: {
    endpoints: {
      login: "POST /api/v1/auth/login";
      logout: "POST /api/v1/auth/logout"; 
      refresh: "POST /api/v1/auth/refresh";
      profile: "GET /api/v1/auth/profile";
    };
    
    tokenFormat: {
      type: "JWT";
      algorithm: "RS256";
      claims: ["sub", "email", "roles", "exp", "iat"];
      header: "Authorization: Bearer {token}";
    };
    
    errorHandling: {
      unauthorized: { status: 401, code: "UNAUTHORIZED" };
      forbidden: { status: 403, code: "FORBIDDEN" };
      tokenExpired: { status: 401, code: "TOKEN_EXPIRED" };
    };
  };
  
  dataAPI: {
    responseFormat: {
      success: "{ data, meta?, links? }";
      error: "{ error: { code, message, details?, requestId } }";
      pagination: "{ data: [], meta: { total, page, perPage, totalPages } }";
    };
    
    filteringAndSorting: {
      queryParams: "filter[field]=value&sort=field:direction";
      operators: ["eq", "ne", "gt", "lt", "gte", "lte", "in", "like"];
      pagination: "page=1&perPage=20";
    };
  };
  
  realTimeAPI: {
    websocket: {
      endpoint: "/ws";
      authentication: "JWT token in connection params";
      eventFormat: "{ type, data, timestamp, userId? }";
    };
    
    eventTypes: [
      "task.created", "task.updated", "task.deleted",
      "project.updated", "user.online", "user.offline", 
      "notification.new", "comment.added"
    ];
  };
}

// Frontend Architecture Generator based on requirements
class FrontendArchitectureGenerator {
  generateArchitecture(context: FrontendProjectContext): FrontendArchitecture {
    return {
      frameworkChoice: this.selectFramework(context),
      stateManagement: this.designStateManagement(context),
      routingStrategy: this.defineRouting(context),
      componentArchitecture: this.designComponents(context),
      performanceStrategy: this.designPerformance(context),
      securityImplementation: this.implementSecurity(context),
      testingStrategy: this.designTesting(context),
      buildOptimization: this.optimizeBuild(context)
    };
  }
  
  private selectFramework(context: FrontendProjectContext): FrameworkChoice {
    // Next.js 14 for most projects due to:
    // - Server-side rendering for performance
    // - Built-in optimization features
    // - Excellent TypeScript support
    // - API route capability for BFF pattern
    
    if (context.realTimeRequirements.critical && context.performanceTargets.strict) {
      return {
        framework: "Next.js 14 with React 18",
        reasoning: "SSR + concurrent features for optimal UX",
        features: ["app-router", "server-components", "streaming", "suspense"]
      };
    }
    
    return {
      framework: "Next.js 14",
      reasoning: "Full-stack React framework with excellent DX",
      features: ["app-router", "server-components", "built-in-optimization"]
    };
  }
}
```

### API Client Architecture
```typescript
// Type-safe API client consuming Backend PRD contracts
interface APIClientArchitecture {
  httpClient: {
    baseImplementation: "fetch-with-interceptors";
    typeGeneration: "openapi-typescript-codegen";
    errorHandling: "consistent-error-boundary-integration";
    retryLogic: "exponential-backoff-with-circuit-breaker";
    caching: "react-query-with-stale-while-revalidate";
  };
  
  authenticationIntegration: {
    tokenStorage: "httponly-cookies-with-csrf-protection";
    tokenRefresh: "automatic-background-refresh";
    logoutHandling: "global-state-cleanup-and-redirect";
    securityHeaders: "automatic-csrf-and-content-type";
  };
  
  realTimeIntegration: {
    websocketClient: "native-websocket-with-reconnection";
    eventHandling: "type-safe-event-dispatching";
    stateSync: "optimistic-updates-with-rollback";
    connectionManagement: "automatic-reconnection-with-backoff";
  };
}

// Implementation: Type-safe API Client
class TypeSafeAPIClient {
  private httpClient: HTTPClient;
  private authStore: AuthStore;
  private wsClient: WebSocketClient;
  
  constructor() {
    this.httpClient = new HTTPClient({
      baseURL: process.env.NEXT_PUBLIC_API_URL,
      timeout: 30000,
      interceptors: {
        request: [this.addAuthHeader, this.addCSRFToken],
        response: [this.handleAuthErrors, this.normalizeResponses]
      }
    });
    
    this.authStore = useAuthStore.getState();
    this.wsClient = new WebSocketClient({
      url: process.env.NEXT_PUBLIC_WS_URL,
      auth: () => this.authStore.token
    });
  }
  
  // Type-safe API methods generated from Backend PRD OpenAPI spec
  async login(credentials: LoginCredentials): Promise<AuthResponse> {
    const response = await this.httpClient.post<AuthResponse>('/api/v1/auth/login', {
      body: credentials,
      schema: LoginCredentialsSchema
    });
    
    // Update auth state on successful login
    if (response.data.token) {
      this.authStore.setAuth(response.data);
      this.wsClient.connect(); // Establish real-time connection
    }
    
    return response.data;
  }
  
  async getProjects(params?: ProjectListParams): Promise<PaginatedResponse<Project>> {
    return this.httpClient.get<PaginatedResponse<Project>>('/api/v1/projects', {
      params,
      schema: ProjectListParamsSchema
    });
  }
  
  async createTask(projectId: string, task: CreateTaskRequest): Promise<Task> {
    const response = await this.httpClient.post<Task>(`/api/v1/projects/${projectId}/tasks`, {
      body: task,
      schema: CreateTaskRequestSchema
    });
    
    // Optimistic update for real-time UX
    this.optimisticTaskUpdate(response.data);
    
    return response.data;
  }
  
  // Real-time event handling
  subscribeToProject(projectId: string, callback: (event: ProjectEvent) => void): UnsubscribeFn {
    return this.wsClient.subscribe(`project:${projectId}`, (event) => {
      // Type-safe event handling based on Backend PRD event types
      switch (event.type) {
        case 'task.created':
          this.handleTaskCreated(event.data);
          break;
        case 'task.updated':
          this.handleTaskUpdated(event.data);
          break;
        case 'user.online':
          this.handleUserOnline(event.data);
          break;
      }
      callback(event);
    });
  }
  
  private async addAuthHeader(config: RequestConfig): Promise<RequestConfig> {
    const token = this.authStore.token;
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  }
  
  private async handleAuthErrors(response: Response): Promise<Response> {
    if (response.status === 401) {
      // Try to refresh token
      const refreshed = await this.authStore.refreshToken();
      if (!refreshed) {
        // Redirect to login if refresh fails
        this.authStore.logout();
        window.location.href = '/login';
      }
    }
    return response;
  }
}
```

## 3. Component Architecture & Design System Integration

### 3.1 Atomic Design Component Hierarchy

**Component Architecture Pattern:**
```typescript
// Comprehensive component architecture following atomic design
interface ComponentArchitecture {
  atoms: {
    purpose: "Basic building blocks - buttons, inputs, icons";
    characteristics: [
      "Single responsibility",
      "Highly reusable", 
      "Design token integration",
      "Accessibility built-in"
    ];
    examples: ["Button", "Input", "Icon", "Avatar", "Badge"];
  };
  
  molecules: {
    purpose: "Simple combinations of atoms";
    characteristics: [
      "Specific UI functionality",
      "Composed of multiple atoms",
      "Business logic abstraction", 
      "Form validation integration"
    ];
    examples: ["SearchBar", "FormField", "UserCard", "TaskItem"];
  };
  
  organisms: {
    purpose: "Complex UI sections";
    characteristics: [
      "Complete interface sections",
      "State management integration",
      "API integration",
      "Real-time updates"
    ];
    examples: ["Header", "Sidebar", "TaskBoard", "ProjectCard"];
  };
  
  templates: {
    purpose: "Page layout structures";
    characteristics: [
      "Layout definition",
      "Responsive behavior",
      "Loading state management",
      "Error boundary integration"
    ];
    examples: ["DashboardLayout", "AuthLayout", "ProjectLayout"];
  };
  
  pages: {
    purpose: "Complete user interfaces";
    characteristics: [
      "Route-level components",
      "Data fetching coordination",
      "SEO optimization",
      "Performance optimization"
    ];
    examples: ["Dashboard", "ProjectDetail", "Settings", "Login"];
  };
}

// Implementation: Base Component Patterns
interface BaseComponentProps {
  className?: string;
  children?: React.ReactNode;
  testId?: string;
}

// Atom Example: Button Component
interface ButtonProps extends BaseComponentProps {
  variant: 'primary' | 'secondary' | 'outline' | 'ghost' | 'destructive';
  size: 'sm' | 'md' | 'lg';
  disabled?: boolean;
  loading?: boolean;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
  fullWidth?: boolean;
  onClick?: () => void;
  type?: 'button' | 'submit' | 'reset';
}

const Button: React.FC<ButtonProps> = ({
  variant = 'primary',
  size = 'md', 
  disabled = false,
  loading = false,
  leftIcon,
  rightIcon,
  fullWidth = false,
  className,
  children,
  testId,
  onClick,
  type = 'button'
}) => {
  const baseStyles = "inline-flex items-center justify-center font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50";
  
  const variantStyles = {
    primary: "bg-blue-600 text-white hover:bg-blue-700 focus-visible:ring-blue-500",
    secondary: "bg-gray-100 text-gray-900 hover:bg-gray-200 focus-visible:ring-gray-500", 
    outline: "border border-gray-300 bg-transparent hover:bg-gray-50 focus-visible:ring-gray-500",
    ghost: "hover:bg-gray-100 focus-visible:ring-gray-500",
    destructive: "bg-red-600 text-white hover:bg-red-700 focus-visible:ring-red-500"
  };
  
  const sizeStyles = {
    sm: "h-8 px-3 text-sm",
    md: "h-10 px-4", 
    lg: "h-12 px-6 text-lg"
  };
  
  const styles = cn(
    baseStyles,
    variantStyles[variant],
    sizeStyles[size],
    fullWidth && "w-full",
    className
  );
  
  return (
    <button
      type={type}
      className={styles}
      disabled={disabled || loading}
      onClick={onClick}
      data-testid={testId}
      aria-busy={loading}
    >
      {loading && <Spinner className="mr-2 h-4 w-4" />}
      {leftIcon && !loading && <span className="mr-2">{leftIcon}</span>}
      {children}
      {rightIcon && <span className="ml-2">{rightIcon}</span>}
    </button>
  );
};

// Molecule Example: FormField Component  
interface FormFieldProps extends BaseComponentProps {
  label?: string;
  error?: string;
  helperText?: string;
  required?: boolean;
  children: React.ReactElement;
}

const FormField: React.FC<FormFieldProps> = ({
  label,
  error,
  helperText,
  required = false,
  children,
  className,
  testId
}) => {
  const fieldId = useId();
  const errorId = error ? `${fieldId}-error` : undefined;
  const helperTextId = helperText ? `${fieldId}-helper` : undefined;
  
  // Clone child element to pass down IDs for accessibility
  const childElement = React.cloneElement(children, {
    id: fieldId,
    'aria-invalid': !!error,
    'aria-describedby': cn(errorId, helperTextId),
    'aria-required': required
  });
  
  return (
    <div className={cn("space-y-2", className)} data-testid={testId}>
      {label && (
        <label 
          htmlFor={fieldId}
          className={cn(
            "block text-sm font-medium text-gray-700",
            required && "after:content-['*'] after:ml-0.5 after:text-red-500"
          )}
        >
          {label}
        </label>
      )}
      
      {childElement}
      
      {error && (
        <p id={errorId} className="text-sm text-red-600" role="alert">
          {error}
        </p>
      )}
      
      {helperText && !error && (
        <p id={helperTextId} className="text-sm text-gray-500">
          {helperText}
        </p>
      )}
    </div>
  );
};

// Organism Example: TaskBoard Component
interface TaskBoardProps extends BaseComponentProps {
  projectId: string;
  columns: TaskColumn[];
  onTaskMove: (taskId: string, newColumnId: string) => void;
  onTaskCreate: (columnId: string, task: Partial<Task>) => void;
}

const TaskBoard: React.FC<TaskBoardProps> = ({
  projectId,
  columns,
  onTaskMove,
  onTaskCreate,
  className,
  testId
}) => {
  // Real-time data integration from Backend PRD
  const { data: tasks, isLoading } = useQuery({
    queryKey: ['tasks', projectId],
    queryFn: () => apiClient.getTasks(projectId)
  });
  
  // Real-time updates via WebSocket
  useEffect(() => {
    const unsubscribe = apiClient.subscribeToProject(projectId, (event) => {
      if (event.type === 'task.updated') {
        queryClient.invalidateQueries(['tasks', projectId]);
      }
    });
    
    return unsubscribe;
  }, [projectId]);
  
  // Drag and drop functionality
  const [draggedTask, setDraggedTask] = useState<Task | null>(null);
  
  const handleDragStart = (task: Task) => {
    setDraggedTask(task);
  };
  
  const handleDrop = (columnId: string) => {
    if (draggedTask && draggedTask.columnId !== columnId) {
      onTaskMove(draggedTask.id, columnId);
    }
    setDraggedTask(null);
  };
  
  if (isLoading) {
    return <TaskBoardSkeleton />;
  }
  
  return (
    <div 
      className={cn("flex gap-6 overflow-x-auto p-6", className)}
      data-testid={testId}
    >
      {columns.map(column => (
        <TaskColumn
          key={column.id}
          column={column}
          tasks={tasks?.filter(task => task.columnId === column.id) || []}
          onDragStart={handleDragStart}
          onDrop={() => handleDrop(column.id)}
          onTaskCreate={(task) => onTaskCreate(column.id, task)}
        />
      ))}
    </div>
  );
};
```

### 3.2 State Management Architecture

**Global State Strategy:**
```typescript
// Zustand-based state management with TypeScript integration
interface AppState {
  // Authentication state (integrates with Security PRD)
  auth: {
    user: User | null;
    token: string | null;
    isAuthenticated: boolean;
    permissions: Permission[];
    login: (credentials: LoginCredentials) => Promise<void>;
    logout: () => void;
    refreshToken: () => Promise<boolean>;
  };
  
  // UI state management
  ui: {
    theme: 'light' | 'dark';
    sidebarOpen: boolean;
    activeModal: string | null;
    loading: Record<string, boolean>;
    toggleSidebar: () => void;
    openModal: (modalId: string) => void;
    closeModal: () => void;
    setLoading: (key: string, loading: boolean) => void;
  };
  
  // Real-time connection state
  realtime: {
    connected: boolean;
    onlineUsers: User[];
    lastActivity: Record<string, Date>;
    connect: () => void;
    disconnect: () => void;
    updateUserActivity: (userId: string) => void;
  };
  
  // Notification state
  notifications: {
    items: Notification[];
    unreadCount: number;
    add: (notification: Notification) => void;
    remove: (id: string) => void;
    markAsRead: (id: string) => void;
    markAllAsRead: () => void;
  };
}

// Implementation: Zustand Store with TypeScript
import { create } from 'zustand';
import { devtools, persist, subscribeWithSelector } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';

// Auth Store
interface AuthState {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  permissions: Permission[];
}

interface AuthActions {
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => void;
  refreshToken: () => Promise<boolean>;
  setUser: (user: User) => void;
  setPermissions: (permissions: Permission[]) => void;
}

const useAuthStore = create<AuthState & AuthActions>()(
  devtools(
    persist(
      immer((set, get) => ({
        // Initial state
        user: null,
        token: null,
        isAuthenticated: false,
        permissions: [],
        
        // Actions
        login: async (credentials) => {
          try {
            const response = await apiClient.login(credentials);
            
            set((state) => {
              state.user = response.user;
              state.token = response.token;
              state.isAuthenticated = true;
              state.permissions = response.permissions;
            });
            
            // Establish real-time connection after login
            useRealtimeStore.getState().connect();
            
          } catch (error) {
            // Handle login error
            throw new AuthenticationError('Login failed', error);
          }
        },
        
        logout: () => {
          // Cleanup all state on logout
          set((state) => {
            state.user = null;
            state.token = null;
            state.isAuthenticated = false;
            state.permissions = [];
          });
          
          // Disconnect real-time connection
          useRealtimeStore.getState().disconnect();
          
          // Clear other stores
          useUIStore.getState().reset();
          useNotificationStore.getState().clear();
          
          // Redirect to login
          window.location.href = '/login';
        },
        
        refreshToken: async () => {
          try {
            const response = await apiClient.refreshToken();
            
            set((state) => {
              state.token = response.token;
              state.user = response.user;
            });
            
            return true;
          } catch (error) {
            // Refresh failed, logout user
            get().logout();
            return false;
          }
        },
        
        setUser: (user) => {
          set((state) => {
            state.user = user;
          });
        },
        
        setPermissions: (permissions) => {
          set((state) => {
            state.permissions = permissions;
          });
        }
      })),
      {
        name: 'auth-storage',
        partialize: (state) => ({
          token: state.token,
          user: state.user,
          isAuthenticated: state.isAuthenticated
        })
      }
    ),
    { name: 'AuthStore' }
  )
);

// UI Store for application-wide UI state
const useUIStore = create<UIState & UIActions>()(
  devtools(
    immer((set) => ({
      theme: 'light',
      sidebarOpen: true,
      activeModal: null,
      loading: {},
      
      toggleSidebar: () => {
        set((state) => {
          state.sidebarOpen = !state.sidebarOpen;
        });
      },
      
      openModal: (modalId) => {
        set((state) => {
          state.activeModal = modalId;
        });
      },
      
      closeModal: () => {
        set((state) => {
          state.activeModal = null;
        });
      },
      
      setLoading: (key, loading) => {
        set((state) => {
          state.loading[key] = loading;
        });
      },
      
      reset: () => {
        set((state) => {
          state.activeModal = null;
          state.loading = {};
        });
      }
    })),
    { name: 'UIStore' }
  )
);

// Server State Management with React Query
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      cacheTime: 10 * 60 * 1000, // 10 minutes
      retry: (failureCount, error) => {
        // Don't retry on auth errors
        if (error?.status === 401 || error?.status === 403) {
          return false;
        }
        return failureCount < 3;
      },
      refetchOnWindowFocus: false
    },
    mutations: {
      retry: false
    }
  }
});

// Custom hooks for server state
export const useProjects = (params?: ProjectListParams) => {
  return useQuery({
    queryKey: ['projects', params],
    queryFn: () => apiClient.getProjects(params),
    enabled: useAuthStore((state) => state.isAuthenticated)
  });
};

export const useTasks = (projectId: string) => {
  return useQuery({
    queryKey: ['tasks', projectId],
    queryFn: () => apiClient.getTasks(projectId),
    enabled: !!projectId && useAuthStore((state) => state.isAuthenticated)
  });
};

export const useCreateTask = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ projectId, task }: { projectId: string; task: CreateTaskRequest }) =>
      apiClient.createTask(projectId, task),
    onSuccess: (data, variables) => {
      // Optimistic update
      queryClient.setQueryData(['tasks', variables.projectId], (old: Task[]) => 
        old ? [...old, data] : [data]
      );
      
      // Show success notification
      useNotificationStore.getState().add({
        type: 'success',
        message: 'Task created successfully',
        duration: 3000
      });
    },
    onError: (error) => {
      // Show error notification  
      useNotificationStore.getState().add({
        type: 'error',
        message: 'Failed to create task',
        duration: 5000
      });
    }
  });
};
```

## 4. Performance Optimization & Core Web Vitals

### 4.1 Performance Architecture

**Performance Strategy Implementation:**
```typescript
// Comprehensive performance optimization following Core Web Vitals
interface PerformanceStrategy {
  coreWebVitals: {
    LCP: {
      target: "< 2.5 seconds";
      optimizations: [
        "image-optimization-with-next-image",
        "preload-critical-resources", 
        "optimize-server-response-times",
        "use-cdn-for-static-assets"
      ];
    };
    
    FID: {
      target: "< 100 milliseconds";
      optimizations: [
        "code-splitting-and-lazy-loading",
        "optimize-javascript-execution",
        "defer-non-critical-scripts",
        "use-react-18-concurrent-features"
      ];
    };
    
    CLS: {
      target: "< 0.1";
      optimizations: [
        "define-size-attributes-for-images",
        "avoid-dynamically-injected-content",
        "use-css-transform-for-animations",
        "reserve-space-for-ads-and-embeds"
      ];
    };
  };
  
  loadingOptimization: {
    codesplitting: "route-based-and-component-based";
    bundleOptimization: "tree-shaking-and-dead-code-elimination";
    assetOptimization: "image-compression-and-format-selection";
    caching: "aggressive-caching-with-proper-invalidation";
  };
  
  runtimeOptimization: {
    rendering: "react-18-concurrent-rendering";
    stateUpdates: "batched-updates-and-transitions";
    listRendering: "virtualization-for-large-lists";
    memoryManagement: "proper-cleanup-and-memoization";
  };
}

// Implementation: Performance Monitoring
class PerformanceMonitor {
  private observer: PerformanceObserver;
  private metrics: Map<string, number> = new Map();
  
  constructor() {
    this.setupPerformanceObserver();
    this.measureCustomMetrics();
  }
  
  private setupPerformanceObserver(): void {
    // Core Web Vitals measurement
    this.observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        switch (entry.entryType) {
          case 'largest-contentful-paint':
            this.recordMetric('LCP', entry.startTime);
            break;
          case 'first-input':
            this.recordMetric('FID', entry.processingStart - entry.startTime);
            break;
          case 'layout-shift':
            if (!entry.hadRecentInput) {
              this.recordMetric('CLS', entry.value);
            }
            break;
          case 'navigation':
            this.recordMetric('TTFB', entry.responseStart);
            break;
        }
      }
    });
    
    this.observer.observe({ 
      entryTypes: ['largest-contentful-paint', 'first-input', 'layout-shift', 'navigation'] 
    });
  }
  
  private measureCustomMetrics(): void {
    // Time to Interactive measurement
    const measureTTI = () => {
      if (document.readyState === 'complete') {
        const tti = performance.now();
        this.recordMetric('TTI', tti);
      }
    };
    
    if (document.readyState === 'complete') {
      measureTTI();
    } else {
      window.addEventListener('load', measureTTI);
    }
    
    // Component render time measurement
    this.measureComponentPerformance();
  }
  
  private recordMetric(name: string, value: number): void {
    this.metrics.set(name, value);
    
    // Send to analytics service
    this.sendToAnalytics(name, value);
    
    // Check thresholds and alert if needed
    this.checkPerformanceThresholds(name, value);
  }
  
  private sendToAnalytics(metricName: string, value: number): void {
    // Integration with analytics service
    if (typeof gtag !== 'undefined') {
      gtag('event', 'web_vitals', {
        event_category: 'Performance',
        event_label: metricName,
        value: Math.round(value),
        custom_parameter_1: window.location.pathname
      });
    }
  }
  
  private checkPerformanceThresholds(name: string, value: number): void {
    const thresholds = {
      LCP: 2500,
      FID: 100,
      CLS: 0.1,
      TTFB: 600
    };
    
    if (thresholds[name] && value > thresholds[name]) {
      console.warn(`Performance threshold exceeded: ${name} = ${value}ms (threshold: ${thresholds[name]}ms)`);
      
      // Send alert to monitoring service
      this.sendPerformanceAlert(name, value, thresholds[name]);
    }
  }
}

// React Performance Optimization Patterns
const usePerformanceOptimizations = () => {
  // Memo for expensive calculations
  const memoizedValue = useMemo(() => {
    return expensiveCalculation(data);
  }, [data]);
  
  // Callback memoization to prevent child re-renders
  const memoizedCallback = useCallback((id: string) => {
    return handleItemClick(id);
  }, []);
  
  // Transition for non-urgent updates
  const [isPending, startTransition] = useTransition();
  
  const handleSearch = (query: string) => {
    startTransition(() => {
      setSearchResults(performSearch(query));
    });
  };
  
  return {
    memoizedValue,
    memoizedCallback,
    handleSearch,
    isPending
  };
};

// Code Splitting Implementation
const LazyProjectDetail = lazy(() => 
  import('./ProjectDetail').then(module => ({
    default: module.ProjectDetail
  }))
);

const LazyTaskBoard = lazy(() =>
  import('./TaskBoard').then(module => ({
    default: module.TaskBoard
  }))
);

// Route-based code splitting with loading states
const AppRouter = () => {
  return (
    <Router>
      <Routes>
        <Route path="/dashboard" element={
          <Suspense fallback={<DashboardSkeleton />}>
            <LazyDashboard />
          </Suspense>
        } />
        <Route path="/projects/:id" element={
          <Suspense fallback={<ProjectDetailSkeleton />}>
            <LazyProjectDetail />
          </Suspense>
        } />
        <Route path="/projects/:id/tasks" element={
          <Suspense fallback={<TaskBoardSkeleton />}>
            <LazyTaskBoard />
          </Suspense>
        } />
      </Routes>
    </Router>
  );
};

// Virtual Scrolling for Large Lists
const VirtualizedTaskList: React.FC<VirtualizedTaskListProps> = ({ 
  tasks, 
  onTaskClick 
}) => {
  const [containerHeight, setContainerHeight] = useState(400);
  const itemHeight = 64;
  const visibleCount = Math.ceil(containerHeight / itemHeight);
  const [scrollTop, setScrollTop] = useState(0);
  
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(startIndex + visibleCount, tasks.length);
  const visibleTasks = tasks.slice(startIndex, endIndex);
  
  return (
    <div 
      className="overflow-auto"
      style={{ height: containerHeight }}
      onScroll={(e) => setScrollTop(e.currentTarget.scrollTop)}
    >
      <div style={{ height: tasks.length * itemHeight, position: 'relative' }}>
        {visibleTasks.map((task, index) => (
          <div
            key={task.id}
            style={{
              position: 'absolute',
              top: (startIndex + index) * itemHeight,
              height: itemHeight,
              width: '100%'
            }}
          >
            <TaskItem task={task} onClick={() => onTaskClick(task)} />
          </div>
        ))}
      </div>
    </div>
  );
};
```

### 4.2 Image and Asset Optimization

**Next.js Image Optimization Integration:**
```typescript
// Optimized Image Component with Performance Features
interface OptimizedImageProps {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  priority?: boolean;
  className?: string;
  objectFit?: 'cover' | 'contain' | 'fill';
  placeholder?: 'blur' | 'empty';
  blurDataURL?: string;
}

const OptimizedImage: React.FC<OptimizedImageProps> = ({
  src,
  alt,
  width,
  height,
  priority = false,
  className,
  objectFit = 'cover',
  placeholder = 'blur',
  blurDataURL
}) => {
  // Generate blur placeholder if not provided
  const generatedBlurDataURL = blurDataURL || generateBlurDataURL(src);
  
  return (
    <Image
      src={src}
      alt={alt}
      width={width}
      height={height}
      priority={priority}
      className={className}
      style={{ objectFit }}
      placeholder={placeholder}
      blurDataURL={generatedBlurDataURL}
      sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
      quality={85}
    />
  );
};

// Progressive Image Loading with Intersection Observer
const ProgressiveImage: React.FC<ProgressiveImageProps> = ({
  src,
  alt,
  lowQualitySrc,
  ...props
}) => {
  const [imageSrc, setImageSrc] = useState(lowQualitySrc);
  const [isLoaded, setIsLoaded] = useState(false);
  const imgRef = useRef<HTMLImageElement>(null);
  
  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          // Load high-quality image when in viewport
          const img = new Image();
          img.onload = () => {
            setImageSrc(src);
            setIsLoaded(true);
          };
          img.src = src;
          observer.disconnect();
        }
      },
      { threshold: 0.1 }
    );
    
    if (imgRef.current) {
      observer.observe(imgRef.current);
    }
    
    return () => observer.disconnect();
  }, [src]);
  
  return (
    <img
      ref={imgRef}
      src={imageSrc}
      alt={alt}
      className={cn(
        "transition-opacity duration-300",
        isLoaded ? "opacity-100" : "opacity-70",
        props.className
      )}
      {...props}
    />
  );
};
```

## 5. Real-time Features & WebSocket Integration

### 5.1 Real-time Architecture

**WebSocket Client Implementation:**
```typescript
// Real-time client integrating with Backend PRD WebSocket specifications
interface RealtimeArchitecture {
  connection: {
    protocol: "WebSocket with automatic reconnection";
    authentication: "JWT token in connection parameters";
    heartbeat: "ping-pong every 30 seconds";
    reconnection: "exponential backoff with max 30 second delay";
  };
  
  eventHandling: {
    dispatch: "type-safe event routing";
    stateSync: "optimistic updates with rollback";
    conflictResolution: "last-write-wins with user notification";
    queueing: "offline event queuing with sync on reconnect";
  };
  
  userExperience: {
    connectionStatus: "visual indicator in UI";
    onlinePresence: "real-time user presence indicators";
    liveUpdates: "immediate UI updates for relevant changes";
    notifications: "in-app notifications for important events";
  };
}

// WebSocket Client Implementation
class RealtimeClient {
  private ws: WebSocket | null = null;
  private url: string;
  private token: string | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 10;
  private reconnectDelay = 1000;
  private heartbeatInterval: NodeJS.Timeout | null = null;
  private messageQueue: QueuedMessage[] = [];
  private eventHandlers: Map<string, Set<EventHandler>> = new Map();
  
  constructor(url: string) {
    this.url = url;
  }
  
  connect(token: string): Promise<void> {
    return new Promise((resolve, reject) => {
      this.token = token;
      const wsUrl = `${this.url}?token=${encodeURIComponent(token)}`;
      
      try {
        this.ws = new WebSocket(wsUrl);
        
        this.ws.onopen = () => {
          console.log('WebSocket connected');
          this.reconnectAttempts = 0;
          this.startHeartbeat();
          this.processMessageQueue();
          useRealtimeStore.getState().setConnected(true);
          resolve();
        };
        
        this.ws.onmessage = (event) => {
          this.handleMessage(JSON.parse(event.data));
        };
        
        this.ws.onclose = (event) => {
          console.log('WebSocket disconnected:', event.code, event.reason);
          this.stopHeartbeat();
          useRealtimeStore.getState().setConnected(false);
          
          if (event.code !== 1000) { // Not normal closure
            this.attemptReconnect();
          }
        };
        
        this.ws.onerror = (error) => {
          console.error('WebSocket error:', error);
          reject(error);
        };
        
      } catch (error) {
        reject(error);
      }
    });
  }
  
  private handleMessage(message: RealtimeMessage): void {
    const { type, data, timestamp, userId } = message;
    
    // Emit to registered handlers
    const handlers = this.eventHandlers.get(type);
    if (handlers) {
      handlers.forEach(handler => handler(data, { timestamp, userId }));
    }
    
    // Handle system events
    switch (type) {
      case 'user.online':
        useRealtimeStore.getState().addOnlineUser(data);
        break;
      case 'user.offline':
        useRealtimeStore.getState().removeOnlineUser(data.userId);
        break;
      case 'task.created':
        this.handleTaskCreated(data);
        break;
      case 'task.updated':
        this.handleTaskUpdated(data);
        break;
      case 'notification.new':
        useNotificationStore.getState().add(data);
        break;
    }
  }
  
  private handleTaskCreated(task: Task): void {
    // Optimistic update: add task to local state
    const queryClient = useQueryClient();
    queryClient.setQueryData(['tasks', task.projectId], (old: Task[]) => 
      old ? [...old, task] : [task]
    );
    
    // Show notification if user is not the creator
    const currentUser = useAuthStore.getState().user;
    if (currentUser && task.createdBy !== currentUser.id) {
      useNotificationStore.getState().add({
        type: 'info',
        message: `New task "${task.title}" created in ${task.projectName}`,
        action: {
          label: 'View',
          onClick: () => window.location.href = `/projects/${task.projectId}/tasks/${task.id}`
        }
      });
    }
  }
  
  private handleTaskUpdated(task: Task): void {
    const queryClient = useQueryClient();
    
    // Update task in cache
    queryClient.setQueryData(['tasks', task.projectId], (old: Task[]) => 
      old ? old.map(t => t.id === task.id ? task : t) : [task]
    );
    
    // Update individual task cache
    queryClient.setQueryData(['task', task.id], task);
  }
  
  subscribe(eventType: string, handler: EventHandler): UnsubscribeFn {
    if (!this.eventHandlers.has(eventType)) {
      this.eventHandlers.set(eventType, new Set());
    }
    this.eventHandlers.get(eventType)!.add(handler);
    
    return () => {
      const handlers = this.eventHandlers.get(eventType);
      if (handlers) {
        handlers.delete(handler);
        if (handlers.size === 0) {
          this.eventHandlers.delete(eventType);
        }
      }
    };
  }
  
  send(message: OutgoingMessage): void {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message));
    } else {
      // Queue message for when connection is restored
      this.messageQueue.push({
        message,
        timestamp: Date.now()
      });
    }
  }
  
  private attemptReconnect(): void {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Max reconnect attempts reached');
      return;
    }
    
    const delay = Math.min(
      this.reconnectDelay * Math.pow(2, this.reconnectAttempts),
      30000
    );
    
    this.reconnectAttempts++;
    console.log(`Attempting to reconnect in ${delay}ms (attempt ${this.reconnectAttempts})`);
    
    setTimeout(() => {
      if (this.token) {
        this.connect(this.token).catch(() => {
          this.attemptReconnect();
        });
      }
    }, delay);
  }
  
  private startHeartbeat(): void {
    this.heartbeatInterval = setInterval(() => {
      if (this.ws?.readyState === WebSocket.OPEN) {
        this.ws.send(JSON.stringify({ type: 'ping' }));
      }
    }, 30000);
  }
  
  private stopHeartbeat(): void {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }
  }
  
  private processMessageQueue(): void {
    while (this.messageQueue.length > 0) {
      const queuedMessage = this.messageQueue.shift();
      if (queuedMessage) {
        this.send(queuedMessage.message);
      }
    }
  }
  
  disconnect(): void {
    this.stopHeartbeat();
    if (this.ws) {
      this.ws.close(1000, 'Client disconnect');
      this.ws = null;
    }
    useRealtimeStore.getState().setConnected(false);
  }
}

// React Hooks for Real-time Features
export const useRealtimeConnection = () => {
  const { token, isAuthenticated } = useAuthStore();
  const { connected } = useRealtimeStore();
  const realtimeClient = useRef<RealtimeClient | null>(null);
  
  useEffect(() => {
    if (isAuthenticated && token && !connected) {
      if (!realtimeClient.current) {
        realtimeClient.current = new RealtimeClient(process.env.NEXT_PUBLIC_WS_URL!);
      }
      
      realtimeClient.current.connect(token).catch(console.error);
    }
    
    return () => {
      if (realtimeClient.current) {
        realtimeClient.current.disconnect();
      }
    };
  }, [isAuthenticated, token, connected]);
  
  return {
    connected,
    client: realtimeClient.current
  };
};

export const useRealtimeSubscription = (
  eventType: string,
  handler: EventHandler,
  deps: any[] = []
) => {
  const { client } = useRealtimeConnection();
  
  useEffect(() => {
    if (client) {
      return client.subscribe(eventType, handler);
    }
  }, [client, eventType, ...deps]);
};

// Real-time User Presence Component
const UserPresence: React.FC<{ userId: string }> = ({ userId }) => {
  const onlineUsers = useRealtimeStore(state => state.onlineUsers);
  const isOnline = onlineUsers.some(user => user.id === userId);
  
  return (
    <div className="flex items-center gap-2">
      <div 
        className={cn(
          "w-2 h-2 rounded-full",
          isOnline ? "bg-green-500" : "bg-gray-300"
        )}
      />
      <span className="text-sm text-gray-600">
        {isOnline ? 'Online' : 'Offline'}
      </span>
    </div>
  );
};

// Live Activity Feed Component
const LiveActivityFeed: React.FC<{ projectId: string }> = ({ projectId }) => {
  const [activities, setActivities] = useState<Activity[]>([]);
  
  useRealtimeSubscription('activity.new', (activity: Activity) => {
    if (activity.projectId === projectId) {
      setActivities(prev => [activity, ...prev.slice(0, 49)]); // Keep last 50
    }
  }, [projectId]);
  
  return (
    <div className="space-y-2">
      <h3 className="font-medium text-gray-900">Live Activity</h3>
      <div className="space-y-1 max-h-96 overflow-y-auto">
        {activities.map(activity => (
          <div key={activity.id} className="flex items-center gap-2 text-sm">
            <UserAvatar user={activity.user} size="sm" />
            <span className="text-gray-600">
              {activity.message}
            </span>
            <span className="text-gray-400 text-xs ml-auto">
              {formatDistanceToNow(activity.timestamp)}
            </span>
          </div>
        ))}
      </div>
    </div>
  );
};
```

## 6. Security Implementation (Frontend)

### 6.1 Client-Side Security Integration

**Frontend Security Implementation Following Security PRD:**
```typescript
// Client-side security implementation integrating with Security PRD
interface FrontendSecurityImplementation {
  authenticationFlow: {
    tokenStorage: "httponly-secure-cookies";
    sessionManagement: "automatic-timeout-and-renewal";
    logoutHandling: "complete-session-cleanup";
    mfaIntegration: "seamless-user-experience";
  };
  
  inputSecurity: {
    validation: "client-side-validation-with-server-verification";
    sanitization: "xss-prevention-with-dompurify";
    encoding: "output-encoding-for-user-content";
    csp: "strict-content-security-policy";
  };
  
  dataProtection: {
    sensitiveDataHandling: "no-sensitive-data-in-localstorage";
    apiCommunication: "https-only-with-certificate-pinning";
    errorHandling: "no-sensitive-data-in-error-messages";
    logging: "client-side-logging-without-pii";
  };
}

// Secure Authentication Hook
const useSecureAuth = () => {
  const authStore = useAuthStore();
  const navigate = useNavigate();
  
  const secureLogin = async (credentials: LoginCredentials): Promise<void> => {
    try {
      // Client-side validation
      const validationResult = validateLoginCredentials(credentials);
      if (!validationResult.valid) {
        throw new ValidationError(validationResult.errors);
      }
      
      // Hash password on client before sending (additional security layer)
      const hashedCredentials = {
        ...credentials,
        password: await hashPassword(credentials.password)
      };
      
      // Call authentication API
      const response = await apiClient.login(hashedCredentials);
      
      // Store authentication state securely
      authStore.setAuth(response);
      
      // Clear any sensitive data from memory
      clearSensitiveData(hashedCredentials);
      
      // Redirect to dashboard
      navigate('/dashboard');
      
    } catch (error) {
      // Secure error handling - don't expose sensitive details
      const userFriendlyError = sanitizeAuthError(error);
      throw userFriendlyError;
    }
  };
  
  const secureLogout = async (): Promise<void> => {
    try {
      // Call logout API to invalidate server session
      await apiClient.logout();
    } catch (error) {
      // Continue with client-side cleanup even if API call fails
      console.warn('Logout API call failed, proceeding with client cleanup');
    } finally {
      // Complete client-side cleanup
      authStore.logout();
      
      // Clear all sensitive data from memory and storage
      clearAllSensitiveData();
      
      // Clear React Query cache
      queryClient.clear();
      
      // Redirect to login
      navigate('/login');
    }
  };
  
  const refreshAuthToken = async (): Promise<boolean> => {
    try {
      const response = await apiClient.refreshToken();
      authStore.setAuth(response);
      return true;
    } catch (error) {
      // Refresh failed, logout user
      await secureLogout();
      return false;
    }
  };
  
  return {
    login: secureLogin,
    logout: secureLogout,
    refreshToken: refreshAuthToken,
    isAuthenticated: authStore.isAuthenticated,
    user: authStore.user
  };
};

// Input Validation and Sanitization
class InputSecurityManager {
  private dompurify: DOMPurify;
  
  constructor() {
    this.dompurify = DOMPurify();
    this.configureDOMPurify();
  }
  
  private configureDOMPurify(): void {
    // Configure DOMPurify for strict sanitization
    this.dompurify.setConfig({
      ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'ul', 'ol', 'li'],
      ALLOWED_ATTR: ['href', 'title'],
      ALLOW_DATA_ATTR: false,
      FORBID_SCRIPT: true,
      FORBID_TAGS: ['script', 'object', 'embed', 'form', 'input'],
      RETURN_DOM: false,
      RETURN_DOM_FRAGMENT: false
    });
  }
  
  validateInput(input: string, type: InputType): ValidationResult {
    const validators = {
      email: (value: string) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),
      password: (value: string) => value.length >= 12,
      url: (value: string) => {
        try {
          new URL(value);
          return true;
        } catch {
          return false;
        }
      },
      text: (value: string) => value.length <= 1000,
      number: (value: string) => /^\d+$/.test(value)
    };
    
    const validator = validators[type];
    if (!validator) {
      throw new Error(`Unknown input type: ${type}`);
    }
    
    const isValid = validator(input);
    return {
      valid: isValid,
      errors: isValid ? [] : [`Invalid ${type} format`]
    };
  }
  
  sanitizeOutput(input: string): string {
    return this.dompurify.sanitize(input);
  }
  
  sanitizeForDisplay(input: string): string {
    // HTML encode for safe display
    return input
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;');
  }
}

// Secure Form Component
interface SecureFormProps {
  onSubmit: (data: Record<string, any>) => Promise<void>;
  validationSchema: z.ZodSchema;
  children: React.ReactNode;
}

const SecureForm: React.FC<SecureFormProps> = ({
  onSubmit,
  validationSchema,
  children
}) => {
  const inputSecurity = useMemo(() => new InputSecurityManager(), []);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [csrfToken, setCsrfToken] = useState<string>('');
  
  // Get CSRF token on component mount
  useEffect(() => {
    const fetchCSRFToken = async () => {
      try {
        const token = await apiClient.getCSRFToken();
        setCsrfToken(token);
      } catch (error) {
        console.error('Failed to fetch CSRF token:', error);
      }
    };
    
    fetchCSRFToken();
  }, []);
  
  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    
    if (isSubmitting) return;
    
    setIsSubmitting(true);
    
    try {
      const formData = new FormData(event.currentTarget);
      const data = Object.fromEntries(formData.entries());
      
      // Client-side validation
      const validationResult = validationSchema.safeParse(data);
      if (!validationResult.success) {
        throw new ValidationError(validationResult.error.errors);
      }
      
      // Sanitize input data
      const sanitizedData = Object.entries(validationResult.data).reduce(
        (acc, [key, value]) => {
          acc[key] = typeof value === 'string' 
            ? inputSecurity.sanitizeOutput(value)
            : value;
          return acc;
        },
        {} as Record<string, any>
      );
      
      // Add CSRF token
      if (csrfToken) {
        sanitizedData._csrf = csrfToken;
      }
      
      // Submit form
      await onSubmit(sanitizedData);
      
    } catch (error) {
      // Handle form submission error
      console.error('Form submission error:', error);
      throw error;
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      {children}
      <input type="hidden" name="_csrf" value={csrfToken} />
    </form>
  );
};

// Content Security Policy Hook
const useContentSecurityPolicy = () => {
  useEffect(() => {
    // Set CSP headers via meta tag for additional protection
    const cspMeta = document.createElement('meta');
    cspMeta.httpEquiv = 'Content-Security-Policy';
    cspMeta.content = [
      "default-src 'self'",
      "script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net",
      "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com",
      "font-src 'self' https://fonts.gstatic.com",
      "img-src 'self' data: https:",
      "connect-src 'self' " + process.env.NEXT_PUBLIC_API_URL,
      "frame-src 'none'",
      "object-src 'none'",
      "base-uri 'self'"
    ].join('; ');
    
    document.head.appendChild(cspMeta);
    
    return () => {
      document.head.removeChild(cspMeta);
    };
  }, []);
};

// Secure Local Storage Alternative
class SecureStorage {
  private encryptionKey: CryptoKey | null = null;
  
  async initialize(): Promise<void> {
    // Generate encryption key for session storage
    this.encryptionKey = await crypto.subtle.generateKey(
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt', 'decrypt']
    );
  }
  
  async setItem(key: string, value: any): Promise<void> {
    if (!this.encryptionKey) {
      throw new Error('SecureStorage not initialized');
    }
    
    const serialized = JSON.stringify(value);
    const encoded = new TextEncoder().encode(serialized);
    const iv = crypto.getRandomValues(new Uint8Array(12));
    
    const encrypted = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv },
      this.encryptionKey,
      encoded
    );
    
    const encryptedData = {
      data: Array.from(new Uint8Array(encrypted)),
      iv: Array.from(iv)
    };
    
    sessionStorage.setItem(key, JSON.stringify(encryptedData));
  }
  
  async getItem(key: string): Promise<any> {
    if (!this.encryptionKey) {
      throw new Error('SecureStorage not initialized');
    }
    
    const stored = sessionStorage.getItem(key);
    if (!stored) return null;
    
    try {
      const { data, iv } = JSON.parse(stored);
      const encryptedData = new Uint8Array(data);
      const ivArray = new Uint8Array(iv);
      
      const decrypted = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv: ivArray },
        this.encryptionKey,
        encryptedData
      );
      
      const decoded = new TextDecoder().decode(decrypted);
      return JSON.parse(decoded);
      
    } catch (error) {
      console.error('Failed to decrypt stored data:', error);
      this.removeItem(key);
      return null;
    }
  }
  
  removeItem(key: string): void {
    sessionStorage.removeItem(key);
  }
  
  clear(): void {
    sessionStorage.clear();
  }
}

// Security Utilities
const SecurityUtils = {
  // Generate secure random strings
  generateSecureToken(length: number = 32): string {
    const array = new Uint8Array(length);
    crypto.getRandomValues(array);
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
  },
  
  // Hash sensitive data for client-side comparison
  async hashPassword(password: string): Promise<string> {
    const encoder = new TextEncoder();
    const data = encoder.encode(password);
    const hash = await crypto.subtle.digest('SHA-256', data);
    return Array.from(new Uint8Array(hash), b => b.toString(16).padStart(2, '0')).join('');
  },
  
  // Clear sensitive data from memory
  clearSensitiveData(obj: any): void {
    if (typeof obj === 'object' && obj !== null) {
      Object.keys(obj).forEach(key => {
        if (typeof obj[key] === 'string') {
          obj[key] = '';
        } else if (typeof obj[key] === 'object') {
          this.clearSensitiveData(obj[key]);
        }
      });
    }
  },
  
  // Sanitize error messages for user display
  sanitizeError(error: any): string {
    const safePart = error.message || 'An error occurred';
    // Remove any potential sensitive information
    return safePart.replace(/\b\d{4}-\d{4}-\d{4}-\d{4}\b/g, '[REDACTED]')
                  .replace(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, '[REDACTED]')
                  .replace(/\b(?:\d{1,3}\.){3}\d{1,3}\b/g, '[REDACTED]');
  }
};
```

## 7. Accessibility Implementation (WCAG 2.1 AA)

### 7.1 Accessibility Architecture

**Comprehensive Accessibility Implementation:**
```typescript
// WCAG 2.1 AA Compliance Implementation
interface AccessibilityImplementation {
  perceivable: {
    textAlternatives: "alt-text-for-all-images";
    captions: "video-captions-and-transcripts";
    adaptable: "semantic-html-and-proper-headings";
    distinguishable: "color-contrast-4.5:1-minimum";
  };
  
  operable: {
    keyboardAccessible: "all-functionality-via-keyboard";
    timing: "user-control-over-time-limits";
    seizures: "no-flashing-content-above-threshold";
    navigable: "skip-links-and-focus-management";
  };
  
  understandable: {
    readable: "clear-language-and-instructions";
    predictable: "consistent-navigation-and-identification";
    inputAssistance: "error-identification-and-suggestions";
  };
  
  robust: {
    compatible: "valid-html-and-aria-compliance";
    futureProof: "semantic-markup-for-assistive-tech";
  };
}

// Accessibility Hook for Focus Management
const useFocusManagement = () => {
  const focusableElementsSelector = [
    'button:not([disabled])',
    '[href]',
    'input:not([disabled])',
    'select:not([disabled])',
    'textarea:not([disabled])',
    '[tabindex]:not([tabindex="-1"])'
  ].join(', ');
  
  const trapFocus = useCallback((container: HTMLElement) => {
    const focusableElements = container.querySelectorAll(focusableElementsSelector);
    const firstElement = focusableElements[0] as HTMLElement;
    const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;
    
    const handleTabKey = (e: KeyboardEvent) => {
      if (e.key === 'Tab') {
        if (e.shiftKey) {
          // Shift + Tab
          if (document.activeElement === firstElement) {
            lastElement.focus();
            e.preventDefault();
          }
        } else {
          // Tab
          if (document.activeElement === lastElement) {
            firstElement.focus();
            e.preventDefault();
          }
        }
      }
      
      if (e.key === 'Escape') {
        // Close modal/dialog on Escape
        container.dispatchEvent(new CustomEvent('escape-pressed'));
      }
    };
    
    container.addEventListener('keydown', handleTabKey);
    
    // Focus first element when trap is activated
    if (firstElement) {
      firstElement.focus();
    }
    
    return () => {
      container.removeEventListener('keydown', handleTabKey);
    };
  }, []);
  
  const restoreFocus = useCallback((previousElement: HTMLElement | null) => {
    if (previousElement && typeof previousElement.focus === 'function') {
      previousElement.focus();
    }
  }, []);
  
  return { trapFocus, restoreFocus };
};

// Accessible Modal Component
interface AccessibleModalProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  description?: string;
  children: React.ReactNode;
}

const AccessibleModal: React.FC<AccessibleModalProps> = ({
  isOpen,
  onClose,
  title,
  description,
  children
}) => {
  const modalRef = useRef<HTMLDivElement>(null);
  const { trapFocus, restoreFocus } = useFocusManagement();
  const previouslyFocusedElement = useRef<HTMLElement | null>(null);
  const titleId = useId();
  const descriptionId = useId();
  
  useEffect(() => {
    if (isOpen) {
      // Store previously focused element
      previouslyFocusedElement.current = document.activeElement as HTMLElement;
      
      // Prevent body scroll
      document.body.style.overflow = 'hidden';
      
      // Trap focus within modal
      if (modalRef.current) {
        const cleanup = trapFocus(modalRef.current);
        
        // Listen for escape key
        const handleEscape = () => onClose();
        modalRef.current.addEventListener('escape-pressed', handleEscape);
        
        return () => {
          cleanup();
          modalRef.current?.removeEventListener('escape-pressed', handleEscape);
        };
      }
    } else {
      // Restore body scroll
      document.body.style.overflow = '';
      
      // Restore focus to previously focused element
      restoreFocus(previouslyFocusedElement.current);
    }
  }, [isOpen, trapFocus, restoreFocus, onClose]);
  
  if (!isOpen) return null;
  
  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50"
      role="dialog"
      aria-modal="true"
      aria-labelledby={titleId}
      aria-describedby={description ? descriptionId : undefined}
    >
      <div
        ref={modalRef}
        className="bg-white rounded-lg shadow-xl max-w-lg w-full mx-4 max-h-[90vh] overflow-y-auto"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="flex items-center justify-between p-4 border-b">
          <h2 id={titleId} className="text-lg font-semibold">
            {title}
          </h2>
          <button
            onClick={onClose}
            className="p-1 rounded-md hover:bg-gray-100 focus:ring-2 focus:ring-blue-500"
            aria-label="Close modal"
          >
            <X className="w-5 h-5" />
          </button>
        </div>
        
        {description && (
          <p id={descriptionId} className="px-4 pt-2 text-gray-600">
            {description}
          </p>
        )}
        
        <div className="p-4">
          {children}
        </div>
      </div>
    </div>
  );
};

// Accessible Form Input Component
interface AccessibleInputProps {
  label: string;
  type?: string;
  value: string;
  onChange: (value: string) => void;
  error?: string;
  helperText?: string;
  required?: boolean;
  disabled?: boolean;
  placeholder?: string;
  autoComplete?: string;
}

const AccessibleInput: React.FC<AccessibleInputProps> = ({
  label,
  type = 'text',
  value,
  onChange,
  error,
  helperText,
  required = false,
  disabled = false,
  placeholder,
  autoComplete
}) => {
  const inputId = useId();
  const errorId = error ? `${inputId}-error` : undefined;
  const helperTextId = helperText ? `${inputId}-helper` : undefined;
  const [announceError, setAnnounceError] = useState(false);
  
  // Announce errors to screen readers
  useEffect(() => {
    if (error) {
      setAnnounceError(true);
      const timer = setTimeout(() => setAnnounceError(false), 1000);
      return () => clearTimeout(timer);
    }
  }, [error]);
  
  return (
    <div className="space-y-1">
      <label 
        htmlFor={inputId}
        className={cn(
          "block text-sm font-medium text-gray-700",
          required && "after:content-['*'] after:ml-0.5 after:text-red-500"
        )}
      >
        {label}
      </label>
      
      <input
        id={inputId}
        type={type}
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder={placeholder}
        autoComplete={autoComplete}
        disabled={disabled}
        required={required}
        aria-invalid={!!error}
        aria-describedby={cn(errorId, helperTextId)}
        className={cn(
          "block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm",
          "focus:ring-2 focus:ring-blue-500 focus:border-blue-500",
          "disabled:bg-gray-50 disabled:text-gray-500",
          error && "border-red-500 focus:border-red-500 focus:ring-red-500"
        )}
      />
      
      {error && (
        <p 
          id={errorId} 
          className="text-sm text-red-600" 
          role="alert"
          aria-live={announceError ? "assertive" : "polite"}
        >
          {error}
        </p>
      )}
      
      {helperText && !error && (
        <p id={helperTextId} className="text-sm text-gray-500">
          {helperText}
        </p>
      )}
    </div>
  );
};

// Skip Navigation Component
const SkipNavigation: React.FC = () => {
  return (
    <a
      href="#main-content"
      className={cn(
        "absolute top-0 left-0 z-50 px-4 py-2 bg-blue-600 text-white",
        "transform -translate-y-full focus:translate-y-0",
        "transition-transform duration-200",
        "focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
      )}
    >
      Skip to main content
    </a>
  );
};

// Accessible Navigation Component
const AccessibleNavigation: React.FC<{ items: NavItem[] }> = ({ items }) => {
  const [activeIndex, setActiveIndex] = useState(0);
  
  const handleKeyDown = (e: React.KeyboardEvent, index: number) => {
    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setActiveIndex((prev) => (prev + 1) % items.length);
        break;
      case 'ArrowUp':
        e.preventDefault();
        setActiveIndex((prev) => (prev - 1 + items.length) % items.length);
        break;
      case 'Home':
        e.preventDefault();
        setActiveIndex(0);
        break;
      case 'End':
        e.preventDefault();
        setActiveIndex(items.length - 1);
        break;
    }
  };
  
  return (
    <nav role="navigation" aria-label="Main navigation">
      <ul role="menubar" className="space-y-1">
        {items.map((item, index) => (
          <li key={item.id} role="none">
            <a
              href={item.href}
              role="menuitem"
              tabIndex={index === activeIndex ? 0 : -1}
              onKeyDown={(e) => handleKeyDown(e, index)}
              onFocus={() => setActiveIndex(index)}
              className={cn(
                "block px-4 py-2 rounded-md transition-colors",
                "focus:ring-2 focus:ring-blue-500 focus:ring-offset-2",
                index === activeIndex && "bg-blue-50 text-blue-700"
              )}
              aria-current={item.current ? "page" : undefined}
            >
              {item.label}
            </a>
          </li>
        ))}
      </ul>
    </nav>
  );
};

// Accessibility Utilities
const AccessibilityUtils = {
  // Announce messages to screen readers
  announceToScreenReader(message: string, priority: 'polite' | 'assertive' = 'polite'): void {
    const announcement = document.createElement('div');
    announcement.setAttribute('aria-live', priority);
    announcement.setAttribute('aria-atomic', 'true');
    announcement.setAttribute('class', 'sr-only');
    announcement.textContent = message;
    
    document.body.appendChild(announcement);
    
    setTimeout(() => {
      document.body.removeChild(announcement);
    }, 1000);
  },
  
  // Check color contrast ratio
  checkColorContrast(foreground: string, background: string): number {
    const getLuminance = (color: string): number => {
      const rgb = parseInt(color.slice(1), 16);
      const r = (rgb >> 16) & 0xff;
      const g = (rgb >> 8) & 0xff;
      const b = (rgb >> 0) & 0xff;
      
      const [rs, gs, bs] = [r, g, b].map(c => {
        c = c / 255;
        return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
      });
      
      return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
    };
    
    const l1 = getLuminance(foreground);
    const l2 = getLuminance(background);
    const lighter = Math.max(l1, l2);
    const darker = Math.min(l1, l2);
    
    return (lighter + 0.05) / (darker + 0.05);
  },
  
  // Generate accessible color combinations
  ensureAccessibleContrast(foreground: string, background: string): string {
    const contrast = this.checkColorContrast(foreground, background);
    
    if (contrast >= 4.5) {
      return foreground; // Already accessible
    }
    
    // Darken or lighten foreground color to meet contrast requirements
    // This is a simplified implementation - in practice, you'd want more sophisticated color manipulation
    return contrast < 3 ? '#000000' : '#333333';
  }
};
```

## 8. Testing Strategy & Quality Assurance

### 8.1 Comprehensive Testing Framework

**Multi-Layer Testing Approach:**
```typescript
// Complete testing strategy for frontend components
interface FrontendTestingStrategy {
  unitTesting: {
    framework: "vitest";
    coverage: {
      statements: 90;
      branches: 85;
      functions: 90;
      lines: 90;
    };
    patterns: [
      "component-logic-testing",
      "hook-testing", 
      "utility-function-testing",
      "state-management-testing"
    ];
  };
  
  integrationTesting: {
    framework: "react-testing-library";
    coverage: [
      "component-interaction-testing",
      "api-integration-testing",
      "routing-testing",
      "real-time-feature-testing"
    ];
  };
  
  e2eTesting: {
    framework: "playwright";
    coverage: [
      "user-workflow-testing",
      "cross-browser-testing",
      "accessibility-testing",
      "performance-testing"
    ];
  };
  
  visualTesting: {
    framework: "storybook-with-chromatic";
    coverage: [
      "component-visual-regression",
      "responsive-design-testing",
      "dark-mode-testing",
      "accessibility-visual-testing"
    ];
  };
}

// Unit Testing Examples
describe('Button Component', () => {
  it('renders with correct variant styles', () => {
    render(<Button variant="primary">Click me</Button>);
    
    const button = screen.getByRole('button', { name: 'Click me' });
    expect(button).toHaveClass('bg-blue-600');
  });
  
  it('handles click events', () => {
    const handleClick = vi.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    
    const button = screen.getByRole('button');
    fireEvent.click(button);
    
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
  
  it('shows loading state correctly', () => {
    render(<Button loading>Loading</Button>);
    
    const button = screen.getByRole('button');
    expect(button).toHaveAttribute('aria-busy', 'true');
    expect(button).toBeDisabled();
    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument();
  });
  
  it('meets accessibility requirements', () => {
    render(<Button>Accessible button</Button>);
    
    const button = screen.getByRole('button');
    expect(button).toHaveAttribute('type', 'button');
    expect(button).not.toHaveAttribute('aria-hidden');
  });
});

// React Hook Testing
describe('useAuth Hook', () => {
  it('handles login flow correctly', async () => {
    const { result } = renderHook(() => useAuth());
    
    const loginCredentials = {
      email: 'test@example.com',
      password: 'password123'
    };
    
    // Mock successful API response
    vi.mocked(apiClient.login).mockResolvedValue({
      user: { id: '1', email: 'test@example.com' },
      token: 'jwt-token'
    });
    
    await act(async () => {
      await result.current.login(loginCredentials);
    });
    
    expect(result.current.isAuthenticated).toBe(true);
    expect(result.current.user).toEqual({
      id: '1',
      email: 'test@example.com'
    });
  });
  
  it('handles login errors', async () => {
    const { result } = renderHook(() => useAuth());
    
    vi.mocked(apiClient.login).mockRejectedValue(
      new Error('Invalid credentials')
    );
    
    await expect(
      result.current.login({ email: 'test@example.com', password: 'wrong' })
    ).rejects.toThrow('Invalid credentials');
    
    expect(result.current.isAuthenticated).toBe(false);
  });
});

// Integration Testing Examples
describe('TaskBoard Integration', () => {
  beforeEach(() => {
    // Setup test environment
    queryClient.clear();
    vi.clearAllMocks();
  });
  
  it('loads and displays tasks correctly', async () => {
    const mockTasks = [
      { id: '1', title: 'Task 1', status: 'todo' },
      { id: '2', title: 'Task 2', status: 'in-progress' }
    ];
    
    vi.mocked(apiClient.getTasks).mockResolvedValue(mockTasks);
    
    render(
      <QueryClientProvider client={queryClient}>
        <TaskBoard projectId="project-1" />
      </QueryClientProvider>
    );
    
    // Wait for tasks to load
    await waitFor(() => {
      expect(screen.getByText('Task 1')).toBeInTheDocument();
      expect(screen.getByText('Task 2')).toBeInTheDocument();
    });
    
    expect(apiClient.getTasks).toHaveBeenCalledWith('project-1');
  });
  
  it('handles real-time task updates', async () => {
    const mockTasks = [{ id: '1', title: 'Task 1', status: 'todo' }];
    vi.mocked(apiClient.getTasks).mockResolvedValue(mockTasks);
    
    // Mock WebSocket client
    const mockWsClient = {
      subscribe: vi.fn(),
      send: vi.fn()
    };
    vi.mocked(useRealtimeConnection).mockReturnValue({
      connected: true,
      client: mockWsClient
    });
    
    render(
      <QueryClientProvider client={queryClient}>
        <TaskBoard projectId="project-1" />
      </QueryClientProvider>
    );
    
    // Verify WebSocket subscription was set up
    await waitFor(() => {
      expect(mockWsClient.subscribe).toHaveBeenCalledWith(
        'project:project-1',
        expect.any(Function)
      );
    });
  });
});

// E2E Testing with Playwright
describe('User Authentication Flow', () => {
  test('user can log in and access dashboard', async ({ page }) => {
    // Navigate to login page
    await page.goto('/login');
    
    // Fill in login form
    await page.fill('[data-testid="email-input"]', 'test@example.com');
    await page.fill('[data-testid="password-input"]', 'password123');
    
    // Submit form
    await page.click('[data-testid="login-button"]');
    
    // Wait for redirect to dashboard
    await page.waitForURL('/dashboard');
    
    // Verify user is logged in
    await expect(page.locator('[data-testid="user-menu"]')).toBeVisible();
    
    // Verify dashboard content loads
    await expect(page.locator('h1')).toContainText('Dashboard');
  });
  
  test('handles login errors gracefully', async ({ page }) => {
    await page.goto('/login');
    
    // Enter invalid credentials
    await page.fill('[data-testid="email-input"]', 'invalid@example.com');
    await page.fill('[data-testid="password-input"]', 'wrongpassword');
    await page.click('[data-testid="login-button"]');
    
    // Verify error message is displayed
    await expect(page.locator('[role="alert"]')).toContainText('Invalid credentials');
    
    // Verify user stays on login page
    expect(page.url()).toContain('/login');
  });
});

// Accessibility Testing
describe('Accessibility Compliance', () => {
  test('keyboard navigation works correctly', async ({ page }) => {
    await page.goto('/dashboard');
    
    // Test Tab navigation
    await page.keyboard.press('Tab');
    await expect(page.locator(':focus')).toHaveAttribute('data-testid', 'skip-nav');
    
    await page.keyboard.press('Tab');
    await expect(page.locator(':focus')).toHaveAttribute('data-testid', 'main-nav');
    
    // Test Arrow key navigation in menus
    await page.keyboard.press('ArrowDown');
    await expect(page.locator('[role="menuitem"][tabindex="0"]')).toBeFocused();
  });
  
  test('screen reader announcements work', async ({ page }) => {
    await page.goto('/dashboard');
    
    // Create a task and verify announcement
    await page.click('[data-testid="create-task-button"]');
    await page.fill('[data-testid="task-title-input"]', 'New Task');
    await page.click('[data-testid="save-task-button"]');
    
    // Verify success announcement
    await expect(page.locator('[aria-live="polite"]')).toContainText('Task created successfully');
  });
  
  test('color contrast meets WCAG requirements', async ({ page }) => {
    await page.goto('/dashboard');
    
    // Check button color contrast
    const button = page.locator('[data-testid="primary-button"]');
    const styles = await button.evaluate((el) => {
      const computed = window.getComputedStyle(el);
      return {
        backgroundColor: computed.backgroundColor,
        color: computed.color
      };
    });
    
    // Verify contrast ratio meets 4.5:1 requirement
    const contrastRatio = calculateColorContrast(styles.color, styles.backgroundColor);
    expect(contrastRatio).toBeGreaterThan(4.5);
  });
});

// Visual Regression Testing with Storybook
// .storybook/main.js configuration for visual testing
export default {
  stories: ['../src/**/*.stories.@(js|jsx|ts|tsx)'],
  addons: [
    '@storybook/addon-essentials',
    '@storybook/addon-a11y',
    '@storybook/addon-viewport',
    '@chromatic-com/storybook'
  ],
  framework: {
    name: '@storybook/nextjs',
    options: {}
  }
};

// Component stories for visual testing
export default {
  title: 'Components/Button',
  component: Button,
  parameters: {
    layout: 'centered'
  },
  argTypes: {
    variant: {
      control: { type: 'select' },
      options: ['primary', 'secondary', 'outline', 'ghost', 'destructive']
    }
  }
};

export const Primary = {
  args: {
    variant: 'primary',
    children: 'Primary Button'
  }
};

export const AllVariants = () => (
  <div className="space-y-4">
    <Button variant="primary">Primary</Button>
    <Button variant="secondary">Secondary</Button>
    <Button variant="outline">Outline</Button>
    <Button variant="ghost">Ghost</Button>
    <Button variant="destructive">Destructive</Button>
  </div>
);

export const LoadingStates = () => (
  <div className="space-y-4">
    <Button loading>Loading Primary</Button>
    <Button variant="secondary" loading>Loading Secondary</Button>
  </div>
);

export const AccessibilityTest = {
  args: {
    children: 'Accessible Button'
  },
  parameters: {
    a11y: {
      config: {
        rules: [
          {
            id: 'color-contrast',
            enabled: true
          }
        ]
      }
    }
  }
};

// Performance Testing
describe('Performance Testing', () => {
  test('page loads within performance budget', async ({ page }) => {
    // Navigate and measure performance
    const response = await page.goto('/dashboard');
    
    // Get performance metrics
    const metrics = await page.evaluate(() => {
      const navigation = performance.getEntriesByType('navigation')[0];
      return {
        domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,
        loadComplete: navigation.loadEventEnd - navigation.loadEventStart,
        firstPaint: performance.getEntriesByName('first-paint')[0]?.startTime || 0,
        firstContentfulPaint: performance.getEntriesByName('first-contentful-paint')[0]?.startTime || 0
      };
    });
    
    // Assert performance budgets
    expect(metrics.firstContentfulPaint).toBeLessThan(2500); // 2.5s FCP target
    expect(metrics.domContentLoaded).toBeLessThan(3000); // 3s DCL target
  });
  
  test('bundle size is within budget', async ({ page }) => {
    await page.goto('/dashboard');
    
    // Get resource sizes
    const resources = await page.evaluate(() => {
      return performance.getEntriesByType('resource')
        .filter(entry => entry.name.includes('.js'))
        .reduce((total, entry) => total + (entry.transferSize || 0), 0);
    });
    
    // Assert bundle size budget (500KB for JS)
    expect(resources).toBeLessThan(500 * 1024);
  });
});
```

## 9. Build Optimization & Deployment

### 9.1 Build Configuration

**Next.js Build Optimization:**
```typescript
// next.config.js - Production-optimized configuration
/** @type {import('next').NextConfig} */
const nextConfig = {
  // Output configuration
  output: 'standalone', // For Docker deployments
  
  // Performance optimizations
  swcMinify: true,
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production',
  },
  
  // Image optimization
  images: {
    domains: ['example.com', 'cdn.example.com'],
    formats: ['image/webp', 'image/avif'],
    minimumCacheTTL: 31536000, // 1 year
    dangerouslyAllowSVG: true,
    contentSecurityPolicy: "default-src 'self'; script-src 'none'; sandbox;",
  },
  
  // Bundle analyzer (dev only)
  bundleAnalyzer: {
    enabled: process.env.ANALYZE === 'true',
  },
  
  // Webpack customization
  webpack: (config, { buildId, dev, isServer, defaultLoaders, webpack }) => {
    // Bundle analysis
    if (process.env.ANALYZE === 'true') {
      const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');
      config.plugins.push(
        new BundleAnalyzerPlugin({
          analyzerMode: 'static',
          openAnalyzer: false,
        })
      );
    }
    
    // Optimize chunks
    if (!dev &&
      